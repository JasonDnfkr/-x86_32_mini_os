### loader 实现

#### 1. 内存检测

编写一个函数`void detect_memory()`，借助BIOS中断实现以下内容：

> **第一次调用时，ES: DI存储保存读取的信息的存储位置**
>
> - 清除EBX，设置为0
> - EDX需要设置成：0x534D4150
> - EAX设置成：0xE820
> - ECX设置成：24
> - 执行INT 0x15
> - 返回结果：EAX = 0x534D4150，CF标志清0，EBX被设置成某个数值用于下次调用，CL=实际读取的字节数
>
> **后续调用：**
>
> - EDX需要设置成：0x534D4150
> - EAX重设为0xE820
> - ECX重设为24
> - 执行INT 0x15
> - 返回结果：EAX = 0x534D4150，CF标志清0。如果EBX=0，则表明读取完毕，否则当前条目有效。

将可用的内存信息，储存至结构体`boot_info`中。

<img src="2_loader_pic/image-20230305230142066.png" alt="image-20230305230142066" style="zoom: 80%;" />

可见有两块可用的内存区域，从 0~654336，1048576~133038080 (即0~640KiB左右，1MiB~128MiB不到的位置)

#### 2. 进入保护模式

CPU上电复位后进入实模式，此模式下没有任何保护机制，但提供了BIOS服务。

**保护模式特性：**

1. 只能访问1MiB内存，内和寄存器最大为16位宽
2. 所有操作数最大为16位
3. 没有任何保护机制
4. 没有特权级
5. 没有分页和虚拟内存

**实模式特性:**

1. 最大可访问内存为4GiB，寄存器位宽为32位
2. 操作数最大为32位，出入栈也为32位
3. 4种特权级，OS最高，应用程序最低
4. 支持分页和虚拟内存

![image-20230305231751462](2_loader_pic/image-20230305231751462.png)



**流程1**: `cli()`关中断

**流程2:** 开启A20地址线，`uint8_t v = inb(0x92)`, `outb(0x92, v | 0x02)`, `lgdt((uint32_t)gdt_table, sizeof(gdt_table))`;

**流程3: **加载gdt表，lgdt

**流程4: **开启保护模式使能位cr0

**流程5: **远跳转；编写汇编代码，取消原16位的指令